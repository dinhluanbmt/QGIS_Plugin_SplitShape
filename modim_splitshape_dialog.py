# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SplitShapeDialog
                                 A QGIS plugin
 Split one Shape file into Grid cells and save to shape files
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-07-14
        git sha              : $Format:%H$
        copyright            : (C) 2023 by modim
        email                : dinhluanbmt@naver.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import Qt, QTimer
from qgis.PyQt.QtWidgets import QFileDialog, QProgressBar, QMessageBox

from qgis.core import QgsProject, QgsVectorLayer, QgsGeometry, QgsRectangle, QgsFeature, QgsPalLayerSettings, QgsTextFormat
from .selectcoordmodule import ClickPointTool

from qgis.gui import QgsMapCanvas
from qgis.core import QgsVectorFileWriter, QgsWkbTypes
from qgis.PyQt.QtCore import QVariant
import processing

#from qgis.PyQt.QtWidgets import QWidget, QVBoxLayout, QProgressBar, QPushButton
#from qgis.PyQt.QtCore import QTimer
#from qgis.PyQt.QtCore import QVariant
#import processing

#from qgis.PyQt.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QWidget, QCheckBox
#from qgis.PyQt.QtCore import Qt
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'modim_splitshape_dialog_base.ui'))


class SplitShapeDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(SplitShapeDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface
        self.shape_to_split = None #global variable
        self.grid_cell_w = 5000
        self.grid_cell_h = 5000
        self.origin_coord_X = 0
        self.origin_coord_Y = 0
        self.max_files_to_save = 100 #maximum nums of cells on grid to save to shape file
        self.plTxtEdit_ShapeInfo.clear()
        self.le_OriginCoord_X.clear()
        self.le_OriginCoord_Y.clear()
        self.progressBar.setValue(0)
        self.le_GridCell_Width.setText(str(self.grid_cell_w))
        self.le_GridCell_Height.setText(str(self.grid_cell_h))
        self.cb_UseCurrentActiveLayer.stateChanged.connect(self.on_UseCurrentActiveLayer_state_changed)
        self.pbBtn_Open_ShapeFile.clicked.disconnect()
        self.pbBtn_Create_Grid.clicked.disconnect()
        self.pbBtn_Change_Origin_Coord.clicked.disconnect()
        self.pbBtn_Save_ShapeFiles.clicked.disconnect()
        #self.pbBtn_Select_OutputFolder.clicked.disconnect()
        self.pbBtn_Open_ShapeFile.clicked.connect(self.on_pbBtn_Open_ShapeFile_clicked)
        self.pbBtn_Create_Grid.clicked.connect(self.on_pbBtn_Create_Grid_clicked)
        self.pbBtn_Select_OutputFolder.clicked.connect(self.on_Btn_Select_OutputFolder_clicked)
        #self.pbBtn_Save_ShapeFiles.clicked.connect(self.on_pbBtn_Save_ShapeFiles_clicked)
        self.pbBtn_Change_Origin_Coord.clicked.connect(self.on_pbBtn_Change_Origin_Coord_clicked)
        self.pbBtn_Save_ShapeFiles.clicked.connect(self.on_pbBtn_Save_ShapeFiles)
        
    def on_pbBtn_Change_Origin_Coord_clicked(self):
        self.plTxtEdit_Result_Message.clear()        
        self.plTxtEdit_Result_Message.setPlainText("Change Coord button clicked")
        self.plTxtEdit_Result_Message.appendPlainText("1. Move mouse to the position you want to select")
        self.plTxtEdit_Result_Message.appendPlainText("2. Right click mouse to select")
        canvas = self.iface.mapCanvas()
        click_tool = ClickPointTool(canvas, self.iface,self.le_OriginCoord_X, self.le_OriginCoord_Y, self.plTxtEdit_Result_Message)
        canvas.setMapTool(click_tool)
        canvas.mousePressEvent = click_tool.canvasPressEvent
        
    def update_progress(self):
        current_value = self.progressBar.value()
        if current_value < 100:
            self.progressBar.setValue(current_value + 10)  # Increment the value by 10
            if current_value + 10 >= 100:
                self.progressBar.setValue(100)
        else:
            self.progressBar.setValue(0)
            self.timer.stop()  # Stop the timer when progress reaches 100
        
    def on_pbBtn_Save_ShapeFiles_clicked(self):
        # Start a QTimer to update the progress bar value after 2 seconds
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_progress)
        self.timer.start(2000)  # 2000 milliseconds = 2 seconds
        
        
    def on_Btn_Select_OutputFolder_clicked(self):
        self.le_Output_Folder.setText('')
        folder_path = QFileDialog.getExistingDirectory(self, "Select Directory")
        # Update the line edit widget with the selected folder path
        if folder_path:
            self.le_Output_Folder.setText(folder_path)
    
    #display the area information of the shape file or current active layer
    def display_shape_info(self,layer):
        if layer is not None:
                self.shape_to_split = layer
                self.lineEdit_InputShapeFile.setEnabled(False)
                self.pbBtn_Open_ShapeFile.setEnabled(False)
                str_l1 ="                  Shape Area Information            "
                self.plTxtEdit_ShapeInfo.setPlainText(str_l1)
                # File path of Shape file
                self.plTxtEdit_ShapeInfo.appendPlainText("1. File Path: " + layer.dataProvider().dataSourceUri())
                # get the With, Height information of shape file 
                extent = layer.extent()
                self.plTxtEdit_ShapeInfo.appendPlainText("2. Width: " + str(int(extent.width())) + "  Height: " + str(int(extent.height())))                
                self.plTxtEdit_ShapeInfo.appendPlainText("3. Grid cell size must be smaller than the With, Height of shape file")
                self.plTxtEdit_ShapeInfo.appendPlainText("4. Cell size too small will create a lot of shape files --> must wait for long time")
                # default Origin Coord point is extent.xMinimum(), and extent.yMinimum()
                self.le_OriginCoord_X.setText(str(int(extent.xMinimum())))
                self.le_OriginCoord_Y.setText(str(int(extent.yMinimum())))
                
    def on_UseCurrentActiveLayer_state_changed(self,state):
        if state == Qt.Checked:
            #print("checked")
            layer = self.iface.activeLayer()
            if layer is not None:
                self.shape_to_split = layer
                self.display_shape_info(self.shape_to_split)
        elif state == Qt.Unchecked:
            #print("unchecked")
            self.plTxtEdit_ShapeInfo.clear()
            self.le_OriginCoord_X.clear()
            self.le_OriginCoord_Y.clear()
            self.lineEdit_InputShapeFile.setEnabled(True)
            self.pbBtn_Open_ShapeFile.setEnabled(True)
    def on_pbBtn_Open_ShapeFile_clicked(self):
        # Open file browser dialog with shapefile filter
        file_dialog = QFileDialog(self)
        file_dialog.setNameFilter("Shapefile (*.shp)")
        file_path, _ = file_dialog.getOpenFileName(None, "Select Shapefile")
        if file_path:            
            self.lineEdit_InputShapeFile.setText(file_path)
            shape_name = os.path.splitext(os.path.basename(file_path))[0]
            self.shape_to_split = self.iface.addVectorLayer(file_path,shape_name,'ogr')
            self.display_shape_info(self.shape_to_split)
            #self.lineEdit_InputShapeFile.setText(shape_name)
        file_dialog.done(0)
        
    #function to create grid
    def on_pbBtn_Create_Grid_clicked(self):
        if self.shape_to_split is None:
            QMessageBox.information(None, "Error","Please select shape file...!")
            return
        #display message
        self.plTxtEdit_Result_Message.clear()
        self.plTxtEdit_Result_Message.setPlainText("Create Grid")
        # get grid cell width, height
        self.grid_cell_w = int(self.le_GridCell_Width.text())
        self.grid_cell_h = int(self.le_GridCell_Height.text())
        #get origin coordinates information
        self.origin_coord_X = int(self.le_OriginCoord_X.text())
        self.origin_coord_Y = int(self.le_OriginCoord_Y.text())
        # Define the cell size and grid extent        
        extent = self.shape_to_split.extent()
        # Define the offset to move the origin
        offset_x = self.origin_coord_X - int(extent.xMinimum())
        offset_y = self.origin_coord_Y - int(extent.yMinimum())
        self.plTxtEdit_Result_Message.appendPlainText(f" offset_x : {offset_x}, offset_y : {offset_y}")

        # Calculate the number of rows and columns for the grid
        if offset_x == 0 and offset_y == 0 :
            rows = int(extent.height() / self.grid_cell_h) + 1
            columns = int(extent.width() / self.grid_cell_w) + 1
            # Calculate the new origin point
            origin_x = extent.xMinimum()
            origin_y = extent.yMinimum()
        else:
            rows = int(extent.height() / self.grid_cell_h) + 2
            columns = int(extent.width() / self.grid_cell_w) + 2
            # Calculate the new origin point            
            origin_x = extent.xMinimum() - (self.grid_cell_w -(offset_x % self.grid_cell_w))
            origin_y = extent.yMinimum() - (self.grid_cell_h -(offset_y % self.grid_cell_h))
            self.plTxtEdit_Result_Message.appendPlainText(f" origin_x : {origin_x}, origin_y : {origin_y}")



        # Create a new memory vector layer for the grid
        grid_layer = QgsVectorLayer('Polygon?crs=' + self.shape_to_split.crs().toWkt(), 'Grid', 'memory')
        grid_layer.setOpacity(0.2)
        grid_provider = grid_layer.dataProvider()
        cell_count = 0
        # Create grid features
        for row in range(rows):
            for col in range(columns):
                # Calculate the coordinates of the grid cell
                #x1 = extent.xMinimum() + col * self.grid_cell_w
                #y1 = extent.yMinimum() + row * self.grid_cell_h
                x1 = origin_x + col * self.grid_cell_w
                y1 = origin_y + row * self.grid_cell_h
                x2 = x1 + self.grid_cell_w
                y2 = y1 + self.grid_cell_h
                cell_count +=1
                # Create a polygon geometry for the grid cell
                geometry = QgsGeometry.fromRect(QgsRectangle(x1, y1, x2, y2))

                # Check if the grid cell's extent intersects with the vector layer extent
                if extent.intersects(geometry.boundingBox()):
                    # Create a new feature and set its geometry
                    feature = QgsFeature()
                    feature.setGeometry(geometry)

                    # Add the feature to the grid layer
                    grid_provider.addFeature(feature)

        self.plTxtEdit_Result_Message.appendPlainText(f"nums of cells in grid {cell_count}")
        # Update the extent
        grid_layer.updateExtents()

        # Add the grid layer to the QGIS project
        QgsProject.instance().addMapLayer(grid_layer)

        # Refresh the map canvas
        self.iface.mapCanvas().refresh()
        
        
    #function to create grid and save all cell in grid as separate shape file
    def on_pbBtn_Save_ShapeFiles(self):
        if self.shape_to_split is None:
            QMessageBox.information(None, "Error","Please select shape file...!")
            return
        if self.le_Output_Folder.text().strip() == '':
            QMessageBox.information(None, "Error ", "Please select Output Folder...!")
            return
        #display message
        self.plTxtEdit_Result_Message.clear()
        self.plTxtEdit_Result_Message.setPlainText("Create Grid")
        # get grid cell width, height
        self.grid_cell_w = int(self.le_GridCell_Width.text())
        self.grid_cell_h = int(self.le_GridCell_Height.text())
        #get origin coordinates information
        self.origin_coord_X = int(self.le_OriginCoord_X.text())
        self.origin_coord_Y = int(self.le_OriginCoord_Y.text())
        # Define the cell size and grid extent        
        extent = self.shape_to_split.extent()
        # Define the offset to move the origin
        offset_x = self.origin_coord_X - int(extent.xMinimum())
        offset_y = self.origin_coord_Y - int(extent.yMinimum())
        self.plTxtEdit_Result_Message.appendPlainText(f" offset_x : {offset_x}, offset_y : {offset_y}")

        # Calculate the number of rows and columns for the grid
        if offset_x == 0 and offset_y == 0 :
            rows = int(extent.height() / self.grid_cell_h) + 1
            columns = int(extent.width() / self.grid_cell_w) + 1
            # Calculate the new origin point
            origin_x = extent.xMinimum()
            origin_y = extent.yMinimum()
        else:
            rows = int(extent.height() / self.grid_cell_h) + 2
            columns = int(extent.width() / self.grid_cell_w) + 2
            # Calculate the new origin point            
            origin_x = extent.xMinimum() - (self.grid_cell_w -(offset_x % self.grid_cell_w))
            origin_y = extent.yMinimum() - (self.grid_cell_h -(offset_y % self.grid_cell_h))
            self.plTxtEdit_Result_Message.appendPlainText(f" origin_x : {origin_x}, origin_y : {origin_y}")



        #check maximum nums of file to save
        if rows*columns > self.max_files_to_save:
            QMessageBox.information(None, "Error","Grid Cell size too small...!\n Please change Grid cell Width, Height...!")
            return
        # Create a new memory vector layer for the grid
        grid_layer = QgsVectorLayer('Polygon?crs=' + self.shape_to_split.crs().toWkt(), 'Grid', 'memory')
        grid_layer.setOpacity(0.2)
        grid_provider = grid_layer.dataProvider()
        cell_count = 0
        # Create grid features
        for row in range(rows):
            for col in range(columns):
                # Calculate the coordinates of the grid cell
                #x1 = extent.xMinimum() + col * self.grid_cell_w
                #y1 = extent.yMinimum() + row * self.grid_cell_h
                x1 = origin_x + col * self.grid_cell_w
                y1 = origin_y + row * self.grid_cell_h
                x2 = x1 + self.grid_cell_w
                y2 = y1 + self.grid_cell_h
                cell_count +=1
                # Create a polygon geometry for the grid cell
                geometry = QgsGeometry.fromRect(QgsRectangle(x1, y1, x2, y2))

                # Check if the grid cell's extent intersects with the vector layer extent
                if extent.intersects(geometry.boundingBox()):
                    # Create a new feature and set its geometry
                    feature = QgsFeature()
                    feature.setGeometry(geometry)

                    # Add the feature to the grid layer
                    grid_provider.addFeature(feature)

        self.plTxtEdit_Result_Message.appendPlainText(f"nums of cells in grid {cell_count}")
        # Update the extent
        grid_layer.updateExtents()

        # Add the grid layer to the QGIS project
        QgsProject.instance().addMapLayer(grid_layer)

        # Refresh the map canvas
        self.iface.mapCanvas().refresh()
        
        # Define the output folder
        #output_folder = 'D:/Tem/'
        output_folder = self.le_Output_Folder.text()+ '/'
        cell_idx = 0

        # Clip the vector layer with the grid cells that have intersection
        clipped_cells = []

        for grid_feature in grid_layer.getFeatures():
            geometry = grid_feature.geometry()

            # Check if the grid cell's extent intersects with the vector layer extent
            if extent.intersects(geometry.boundingBox()):
                # Create a memory layer with the grid cell geometry
                grid_mem_layer = QgsVectorLayer('Polygon?crs=' + self.shape_to_split.crs().toWkt(), 'GridCell', 'memory')
                grid_mem_layer_data = grid_mem_layer.dataProvider()
                grid_mem_layer_data.addFeature(grid_feature)

                # Perform the clip operation
                params = {
                    'INPUT': self.shape_to_split,
                    'OVERLAY': grid_mem_layer,
                    'OUTPUT': 'memory:'
                }

                result = processing.run("native:clip", params)
                clipped_layer = result['OUTPUT']

                # Check if the clipped cell has any features
                if clipped_layer.featureCount() > 0:
                    # Set the name of the clipped layer using the cell ID
                    #cell_id = grid_feature.id()
                    clipped_layer.setName(f'cell_{cell_idx + 1 }')
                    cell_idx = cell_idx + 1
                    clipped_cells.append(clipped_layer)

        # Save each clipped cell as a separate shapefile
        for index, clipped_cell in enumerate(clipped_cells):
            output_path = f'{output_folder}cell_{index + 1}.shp'  # Unique filename for each cell
            QgsVectorFileWriter.writeAsVectorFormat(clipped_cell, output_path, 'UTF-8', clipped_cell.crs(), 'ESRI Shapefile')
            
            # set progress bar 
            per_val = (index +1)*100/(cell_idx)
            current_value = self.progressBar.value()
            if current_value < 100:
                self.progressBar.setValue(current_value + per_val)  # Increment the value by 10
            if current_value + per_val >= 100:
                self.progressBar.setValue(100)
            # Add the clipped layer to the QGIS project
            QgsProject.instance().addMapLayer(clipped_cell)
        # Refresh the map canvas
        self.iface.mapCanvas().refresh()
        self.progressBar.setValue(100)
        
        self.plTxtEdit_Result_Message.clear()        
        self.plTxtEdit_Result_Message.setPlainText("Finished...")
        self.plTxtEdit_Result_Message.appendPlainText(f"Total : {index+1} shape files saved")
        self.plTxtEdit_Result_Message.appendPlainText("Check output folder for results.")
        # Start a QTimer to update the progress bar value after 2 seconds
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_progress)
        self.timer.start(2000)  # 2000 milliseconds = 2 seconds

        # Print a success message
        #print('Clipping completed successfully.')
        # end function
